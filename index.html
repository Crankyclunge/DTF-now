<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DTF Now - Professional Edition</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Professional DTF printing tool - remove black backgrounds instantly">
    <meta name="theme-color" content="#00d4ff">
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS Specific Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DTF Now">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: 100vh;
            gap: 15px;
            padding: 15px;
        }

        /* Sidebar */
        .sidebar {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #0ea5e9;
            border-radius: 4px;
        }

        .logo {
            margin-bottom: 20px;
        }

        .logo h1 {
            font-size: 28px;
            font-weight: 800;
            color: #0ea5e9;
            margin-bottom: 5px;
        }

        .logo p {
            font-size: 12px;
            color: #a1a1aa;
        }

        .divider {
            height: 1px;
            background: #3f3f46;
            margin: 20px 0;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 700;
            color: #a1a1aa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: #0ea5e9;
            color: #0a0a0a;
        }

        .btn-primary:hover {
            background: #22d3ee;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #22c55e;
            color: #0a0a0a;
        }

        .btn-success:hover {
            background: #4ade80;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #ffffff;
        }

        .btn-secondary:hover {
            background: #3f3f46;
        }

        /* Sliders */
        .slider-container {
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .slider-value {
            color: #0ea5e9;
            font-weight: 700;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2a2a2a;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0ea5e9;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #22d3ee;
            transform: scale(1.2);
        }

        /* Color picker */
        .color-picker {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }

        .color-display {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid #0ea5e9;
            cursor: pointer;
        }

        .color-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
        }

        .btn-small {
            padding: 8px 12px;
            font-size: 12px;
        }

        /* Checkboxes */
        .checkbox-group {
            margin: 15px 0;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .checkbox-label:hover {
            background: #2a2a2a;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Radio buttons */
        .radio-group {
            margin: 10px 0;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.2s;
            font-size: 13px;
        }

        .radio-label:hover {
            background: #2a2a2a;
        }

        input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Canvas Area */
        .canvas-area {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .canvas-title {
            font-size: 18px;
            font-weight: 700;
        }

        .stats {
            font-size: 12px;
            color: #a1a1aa;
        }

        .canvas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            flex: 1;
        }

        .canvas-wrapper {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .canvas-label {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .canvas-label.original {
            color: #a1a1aa;
        }

        .canvas-label.processed {
            color: #0ea5e9;
        }

        .canvas-label::before {
            content: '‚óè';
            font-size: 8px;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            border: 1px solid #3f3f46;
            background: #0a0a0a;
            cursor: crosshair;
        }

        .zoom-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .zoom-display {
            flex: 1;
            background: #2a2a2a;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            font-size: 20px;
            font-weight: 700;
            color: #0ea5e9;
        }

        /* Info box */
        .info-box {
            background: #2a2a2a;
            border-left: 3px solid #22d3ee;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #a1a1aa;
            margin: 10px 0;
        }

        /* Hidden file input */
        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo">
                <h1>DTF Now</h1>
                <p>Professional Edition</p>
            </div>

            <div class="divider"></div>

            <!-- File Operations -->
            <div class="section">
                <div class="section-title">Files</div>
                <input type="file" id="fileInput" accept="image/*">
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                    üìÅ Load Image
                </button>
                <button class="btn btn-success" onclick="saveImage()">
                    üíæ Save Result
                </button>
            </div>

            <div class="divider"></div>

            <!-- Threshold -->
            <div class="section">
                <div class="section-title">Threshold</div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Value</span>
                        <span class="slider-value" id="thresholdValue">90</span>
                    </div>
                    <input type="range" id="threshold" min="10" max="200" value="90" oninput="updateThreshold(this.value)">
                </div>
                <button class="btn btn-secondary btn-small" onclick="autoDetectThreshold()">
                    üéØ Auto-Detect
                </button>
            </div>

            <div class="divider"></div>

            <!-- Color Removal -->
            <div class="section">
                <div class="section-title">Color Removal</div>
                <div class="color-picker">
                    <div class="color-display" id="colorDisplay" style="background: #000000;" onclick="pickColor()"></div>
                    <div class="color-buttons">
                        <button class="btn btn-secondary btn-small" onclick="setColor(0,0,0)">Black</button>
                        <button class="btn btn-secondary btn-small" onclick="setColor(255,255,255)">White</button>
                        <button class="btn btn-primary btn-small" onclick="enableEyedropper()">üëÅ Eyedropper</button>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Stroke -->
            <div class="section">
                <div class="section-title">Stroke</div>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="strokeEnabled" onchange="toggleStroke()">
                        <span>Add 1px Stroke</span>
                    </label>
                </div>
                <div class="color-picker">
                    <input type="color" id="strokeColor" value="#000000" style="display: none;">
                    <div class="color-display" id="strokeColorDisplay" style="background: #000000;" onclick="pickStrokeColor()"></div>
                    <div class="color-buttons">
                        <button class="btn btn-secondary btn-small" onclick="pickStrokeColor()">Pick Color</button>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Rotation -->
            <div class="section">
                <div class="section-title">Rotate</div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-secondary" onclick="rotate(-90)" style="flex: 1;">‚Ü∂ 90¬∞</button>
                    <button class="btn btn-secondary" onclick="rotate(90)" style="flex: 1;">‚Ü∑ 90¬∞</button>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Shirt Size -->
            <div class="section">
                <div class="section-title">Print Size</div>
                <div class="radio-group">
                    <label class="radio-label">
                        <input type="radio" name="size" value="XS-S" checked>
                        <span>XS-S (10√ó12 in)</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="size" value="M-L">
                        <span>M-L (12√ó16 in)</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="size" value="XL-2XL">
                        <span>XL-2XL (14√ó18 in)</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="size" value="3XL-5XL">
                        <span>3XL-5XL (15√ó20 in)</span>
                    </label>
                </div>
            </div>

            <div class="divider"></div>



            <div class="info-box">
                üí° Tip: Left-click on image to zoom in, right-click to zoom out
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area">
            <div class="canvas-header">
                <div class="canvas-title">Preview</div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <span style="font-size: 12px; color: #a1a1aa;">Background:</span>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 13px;">
                        <input type="radio" name="bgmode" value="checkerboard" checked onchange="updateDisplay()" style="cursor: pointer;">
                        <span>Checkerboard</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 13px;">
                        <input type="radio" name="bgmode" value="white" onchange="updateDisplay()" style="cursor: pointer;">
                        <span>White</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 13px;">
                        <input type="radio" name="bgmode" value="black" onchange="updateDisplay()" style="cursor: pointer;">
                        <span>Black</span>
                    </label>
                </div>
                <div class="stats" id="stats">No image loaded</div>
            </div>

            <div class="canvas-grid">
                <div class="canvas-wrapper">
                    <div class="canvas-label original">Original</div>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <div class="canvas-label processed">Processed</div>
                    <canvas id="processedCanvas"></canvas>
                </div>
            </div>

            <div class="zoom-controls">

                <div class="zoom-display" id="zoomLevel">100%</div>
                <button class="btn btn-secondary" onclick="resetZoom()" style="flex: 1;">Reset</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let originalImage = null;
        let processedImage = null;
        let threshold = 90;
        let removalColor = [0, 0, 0];
        let strokeColor = [0, 0, 0];
        let rotation = 0;
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let eyedropperMode = false;
        let strokeEyedropperMode = false;

        const originalCanvas = document.getElementById('originalCanvas');
        const processedCanvas = document.getElementById('processedCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const processedCtx = processedCanvas.getContext('2d');

        // Resize canvases to fit
        function resizeCanvases() {
            const wrapper = document.querySelector('.canvas-wrapper');
            const rect = wrapper.getBoundingClientRect();
            originalCanvas.width = rect.width - 30;
            originalCanvas.height = rect.height - 60;
            processedCanvas.width = rect.width - 30;
            processedCanvas.height = rect.height - 60;
        }

        window.addEventListener('resize', () => {
            resizeCanvases();
            updateDisplay();
        });

        resizeCanvases();

        // Load image
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    rotation = 0;
                    processImage();
                    // Auto-fit will happen after processing completes
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Process image
        function processImage() {
            if (!originalImage) return;

            // Create canvas for processing
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = originalImage.width;
            tempCanvas.height = originalImage.height;

            // Apply rotation
            if (rotation !== 0) {
                tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                tempCtx.rotate((rotation * Math.PI) / 180);
                tempCtx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
                tempCtx.setTransform(1, 0, 0, 1, 0, 0);
            } else {
                tempCtx.drawImage(originalImage, 0, 0);
            }

            // Get image data
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;

            // Remove color
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // Calculate color distance
                const distance = Math.sqrt(
                    Math.pow(r - removalColor[0], 2) +
                    Math.pow(g - removalColor[1], 2) +
                    Math.pow(b - removalColor[2], 2)
                );

                const normalizedDistance = (distance / 441) * 255;

                if (normalizedDistance < threshold) {
                    data[i + 3] = 0; // Make transparent
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Apply stroke if enabled
            const strokeEnabled = document.getElementById('strokeEnabled').checked;
            console.log('Stroke enabled:', strokeEnabled);
            if (strokeEnabled) {
                const strokeColorInput = document.getElementById('strokeColor').value;
                console.log('Applying stroke with color:', strokeColorInput);
                const r = parseInt(strokeColorInput.substr(1, 2), 16);
                const g = parseInt(strokeColorInput.substr(3, 2), 16);
                const b = parseInt(strokeColorInput.substr(5, 2), 16);
                
                // Get image data
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                const width = tempCanvas.width;
                const height = tempCanvas.height;
                
                // Create copy of alpha channel
                const originalAlpha = new Uint8ClampedArray(width * height);
                for (let i = 0; i < width * height; i++) {
                    originalAlpha[i] = data[i * 4 + 3];
                }
                
                // Dilate by 1px (expand visible area)
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = y * width + x;
                        const pixelIndex = i * 4;
                        
                        // Skip if already fully opaque
                        if (originalAlpha[i] === 255) continue;
                        
                        // Check if any neighbor is visible
                        let hasVisibleNeighbor = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const ni = ny * width + nx;
                                    if (originalAlpha[ni] > 0) {
                                        hasVisibleNeighbor = true;
                                        break;
                                    }
                                }
                            }
                            if (hasVisibleNeighbor) break;
                        }
                        
                        // If has visible neighbor and current alpha < 250, make it stroke
                        if (hasVisibleNeighbor && originalAlpha[i] < 250) {
                            data[pixelIndex] = r;
                            data[pixelIndex + 1] = g;
                            data[pixelIndex + 2] = b;
                            data[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                console.log('Stroke applied to canvas');
            }

            // Auto-crop
            const cropped = autoCrop(tempCanvas);
            
            // Create processed image
            processedImage = new Image();
            processedImage.onload = () => {
                updateDisplay();
                updateStats();
                // Auto-reset to 100% after processing is complete
                setTimeout(() => resetZoom(), 100);
            };
            processedImage.src = cropped.toDataURL();
        }

        // Auto-crop transparent areas
        function autoCrop(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const alpha = data[(y * canvas.width + x) * 4 + 3];
                    if (alpha > 0) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            const width = maxX - minX + 1;
            const height = maxY - minY + 1;

            if (width <= 0 || height <= 0) return canvas;

            const croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = width;
            croppedCanvas.height = height;
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCtx.drawImage(canvas, minX, minY, width, height, 0, 0, width, height);

            return croppedCanvas;
        }

        // Update display
        function updateDisplay() {
            // Clear canvases
            originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);

            if (!originalImage) return;

            // Draw original
            drawImageOnCanvas(originalImage, originalCtx, originalCanvas);

            // Draw processed
            if (processedImage) {
                drawImageOnCanvas(processedImage, processedCtx, processedCanvas);
            }
        }

        function drawImageOnCanvas(img, ctx, canvas) {
            const bgMode = document.querySelector('input[name="bgmode"]:checked').value;

            // Draw background
            if (bgMode === 'checkerboard') {
                drawCheckerboard(ctx, canvas.width, canvas.height);
            } else if (bgMode === 'white') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (bgMode === 'black') {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Calculate display size
            const scale = Math.min(
                canvas.width / img.width,
                canvas.height / img.height
            ) * zoomLevel;

            const width = img.width * scale;
            const height = img.height * scale;
            const x = (canvas.width - width) / 2 + panX;
            const y = (canvas.height - height) / 2 + panY;

            ctx.drawImage(img, x, y, width, height);
        }

        function drawCheckerboard(ctx, width, height) {
            const size = 20;
            for (let y = 0; y < height; y += size) {
                for (let x = 0; x < width; x += size) {
                    ctx.fillStyle = ((x / size + y / size) % 2 === 0) ? '#2a2a2a' : '#3f3f46';
                    ctx.fillRect(x, y, size, size);
                }
            }
        }

        // Threshold with debouncing for performance
        let thresholdTimeout = null;
        function updateThreshold(value) {
            threshold = parseInt(value);
            document.getElementById('thresholdValue').textContent = threshold;
            
            // Debounce - only process after user stops sliding
            clearTimeout(thresholdTimeout);
            thresholdTimeout = setTimeout(() => {
                processImage();
            }, 150); // Wait 150ms after last change
        }

        function autoDetectThreshold() {
            threshold = 90; // Simple default
            document.getElementById('threshold').value = threshold;
            document.getElementById('thresholdValue').textContent = threshold;
            processImage();
            alert('Threshold set to 90 (optimal for most images)');
        }

        // Color
        function setColor(r, g, b) {
            removalColor = [r, g, b];
            document.getElementById('colorDisplay').style.background = `rgb(${r},${g},${b})`;
            processImage();
        }

        function pickColor() {
            const input = document.createElement('input');
            input.type = 'color';
            input.click();
            input.addEventListener('change', (e) => {
                const hex = e.target.value;
                const r = parseInt(hex.substr(1, 2), 16);
                const g = parseInt(hex.substr(3, 2), 16);
                const b = parseInt(hex.substr(5, 2), 16);
                setColor(r, g, b);
            });
        }

        function setStrokeColor(r, g, b) {
            const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            document.getElementById('strokeColor').value = hex;
            document.getElementById('strokeColorDisplay').style.background = hex;
            strokeColor = [r, g, b];
            processImage();
        }

        function enableEyedropper() {
            eyedropperMode = true;
            strokeEyedropperMode = false;
            originalCanvas.style.cursor = 'crosshair';
            alert('Click on the image to pick a color to remove');
        }
        
        function enableStrokeEyedropper() {
            strokeEyedropperMode = true;
            eyedropperMode = false;
            originalCanvas.style.cursor = 'crosshair';
            alert('Click on the image to pick a stroke color');
        }

        // Stroke
        function toggleStroke() {
            processImage();
        }

        function pickStrokeColor() {
            const input = document.getElementById('strokeColor');
            input.click();
            input.addEventListener('change', (e) => {
                const hex = e.target.value;
                strokeColor = [
                    parseInt(hex.substr(1, 2), 16),
                    parseInt(hex.substr(3, 2), 16),
                    parseInt(hex.substr(5, 2), 16)
                ];
                document.getElementById('strokeColorDisplay').style.background = hex;
            });
        }

        // Rotation
        function rotate(degrees) {
            rotation = (rotation + degrees) % 360;
            processImage();
        }

        // Zoom


        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            document.getElementById('zoomLevel').textContent = '100%';
            updateDisplay();
        }

        // Canvas click for zoom or eyedropper
        originalCanvas.addEventListener('click', (e) => {
            if (eyedropperMode || strokeEyedropperMode) {
                // Get click position relative to canvas
                const rect = originalCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                
                // Calculate where image is drawn on canvas
                const scale = Math.min(
                    originalCanvas.width / originalImage.width,
                    originalCanvas.height / originalImage.height
                ) * zoomLevel;
                
                const imgWidth = originalImage.width * scale;
                const imgHeight = originalImage.height * scale;
                const imgX = (originalCanvas.width - imgWidth) / 2 + panX;
                const imgY = (originalCanvas.height - imgHeight) / 2 + panY;
                
                // Convert to image coordinates
                const clickX = canvasX - imgX;
                const clickY = canvasY - imgY;
                const origX = Math.floor(clickX / scale);
                const origY = Math.floor(clickY / scale);
                
                // Check if click is within image
                if (origX >= 0 && origX < originalImage.width && origY >= 0 && origY < originalImage.height) {
                    // Create temporary canvas to read pixel
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = originalImage.width;
                    tempCanvas.height = originalImage.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(originalImage, 0, 0);
                    
                    const pixel = tempCtx.getImageData(origX, origY, 1, 1).data;
                    
                    if (eyedropperMode) {
                        setColor(pixel[0], pixel[1], pixel[2]);
                        eyedropperMode = false;
                    } else if (strokeEyedropperMode) {
                        setStrokeColor(pixel[0], pixel[1], pixel[2]);
                        strokeEyedropperMode = false;
                    }
                    originalCanvas.style.cursor = '';
                }
                return;
            }
            zoomLevel = Math.min(zoomLevel + 0.1, 3.0);
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
            updateDisplay();
        });

        originalCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            zoomLevel = Math.max(zoomLevel - 0.1, 0.1);
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
            updateDisplay();
        });

        // Pan/drag functionality when zoomed in
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;

        originalCanvas.addEventListener('mousedown', (e) => {
            // Only allow dragging if zoomed in and not in eyedropper mode
            if (zoomLevel > 1.0 && !eyedropperMode && !strokeEyedropperMode) {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                dragStartPanX = panX;
                dragStartPanY = panY;
                originalCanvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;
                panX = dragStartPanX + dx;
                panY = dragStartPanY + dy;
                updateDisplay();
            }
        });

        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                originalCanvas.style.cursor = zoomLevel > 1.0 ? 'grab' : '';
            }
        });

        // Update cursor when zoom changes
        const originalUpdateDisplay = updateDisplay;
        updateDisplay = function() {
            originalUpdateDisplay();
            if (!eyedropperMode && !strokeEyedropperMode && !isDragging) {
                originalCanvas.style.cursor = zoomLevel > 1.0 ? 'grab' : '';
            }
        };

        // Stats
        function updateStats() {
            if (!processedImage) {
                document.getElementById('stats').textContent = 'No image processed';
                return;
            }
            document.getElementById('stats').textContent = 
                `${processedImage.width}√ó${processedImage.height}px`;
        }

        // Save
        function saveImage() {
            if (!processedImage) {
                alert('No processed image to save!');
                return;
            }

            const size = document.querySelector('input[name="size"]:checked').value;
            const link = document.createElement('a');
            link.download = `DTF_Output_${size}.png`;
            link.href = processedImage.src;
            link.click();
        }
    </script>
    
    <!-- PWA Service Worker Registration -->
    <script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('service-worker.js')
                .then(registration => {
                    console.log('ServiceWorker registered:', registration.scope);
                })
                .catch(error => {
                    console.log('ServiceWorker registration failed:', error);
                });
        });
    }
    </script>
</body>
</html>
